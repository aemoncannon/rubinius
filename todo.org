
* Regression tests!!!

* Exception handling
  - Recording needs to bail if an exception is thrown!
  - Exception handling code at jit_trace.cpp #377 - what is that?
  - setup_unwind, pop_unwind (handlers are linked in PassOne)
  - push_exception_state, pop_exception_state (for saving state to stack)
** Plan
   - What happens in method JIT:
       - Instead of UnwindInfos, JITBasicBlocks hold info for exception handler
       - Exception handling is handled entirely in JITed code (see visit_setup_unwind)
       - If no handlers, jump to bail_out_fast, which returns nil to interp
       - I _think_ current_unwind == 0 at this point, so interp exceptio handler just 
	 returns to caller, handing over control of the exception to the caller

   - So for Trace:

     - We assume we won't hit a raise that wasn't recorded.

     - During recording, keep track of all the setup_unwind targets (ip and call_frame). 
       If we hit a raise, followed by a an instruction at one of the 
       unwind targets, then we know it's been rescued 'on trace'. Continue 
       recording.

       Otherwise, if the next instruction is not on same call_frame, or not at
       one of the recorded unwind targets, then throw away the recording.

       - So, when we're emitting code, we can ignore the setup_unwind.
	 Any raise conditions are by defintion rescued and handled on trace.
	 BUT, we do need to setup the correct call_frame and variable structure 
	 (similiar to a traced return, but might have popped more than one frame).

     - So consider the raise to be like a long, unconditional jump.


       



* Exiting to same call frame.
  - Say we hit a trace from the interpreter, and run it. If we exit the trace on the same callframe, 
    should be able to just continue at the exit ip, exit stack, right? We disallow raising exceptions
    on traces... so the exception context should be ok.
