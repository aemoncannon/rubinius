

Sun Oct 26, 1:42
  Ok, outerlining is crashing because I never accounted for side-exits in traces that have already returned from the home frame. So in a nested function situation, when a branch outerlines a loop, returning back into the caller, its possible to have side-exits that would require us to pop the trace home frame. :(  My take: let's just disallow traces that return from the anchor's home frame. We can still do outerlining, just not in nested function situtations.


Sun Oct 24, 11:17
  So the reason nested_funcs.rb is failing in exit-on-exception branch is because of the new benchmarking harness. For whatever reason, if we run the interpreted version prior to running th traced version, in the same Ruby process, the tracer will generate a nested trace and all will work. But, if we just run the traced version, the tracer will 'outerline' the outer loop and we get a crash. Take-aways: 1) need to figure out why running interp version first would make any difference. 2) need to figure out where the outerlining crash is coming from.


Trace runtime interfaces
-------------------------

Requirements
 - Should optimize for speed of switching to branch traces. Because # of branch runs is potentially related to N (iterations) of loop.
   As opposed to exits that leave the trace, which will be run once per trace run.
 - Would be nice if nested exits were also fast. Bailing to interpreter on nested exit would make this slow - so don't do that.

NESTED flag 
 - Purpose is to notify the trace to return directly to calling trace (on expected exit), 
   instead of bailing to the uncommon interpreter. Return 1 if nested trace exited politely so the parent 
   trace can just continue. Otherwise return -1 and we collapse. For branches and nests of the nested trace,
   we don't need them to do anything special. Branches are either successful or collapse. Nests are either
   successful or collapse.

RECORDING flag
 - Like above, but we don't care what pc the trace exits at. We do need to remember this pc, because future runs
   of this nested trace must exit here. 


Problem with always directly calling branch traces:
 - The traceinfo that we pass to the call is either the info for the parent trace, or the info for the new branch trace.
 - What info do we actually need to pass? not NESTED/RECORDING flag (since it's a branch). Entry call_frame? No, we can
   grab this at runtime. Exit call_frame? No, we'll know this at exit time. Expected exit ip? No, don't need this on 
   branch trace. Exit ip, exit trace node can be setup on exit.

 - So, what if we have two things. A NESTED/RECORDING flag passed as an argument. And a trace_info which is always interpreted
   as information describing the previous trace's run - exit_node, exit_ip. 

 - If the 

   
    
 





